{"version":3,"sources":["editPost.js"],"names":["_mongoose","_interopRequireDefault","require","_db","postSchema","mongoose","Schema","message","String","timestamp","Date","username","sessionId","likes","type","Number","default","dislikes","likedBy","dislikedBy","comments","comment","model","res","setHeader","handler","req","_req$body","postId","action","post","regeneratorRuntime","async","_context","prev","next","method","abrupt","status","end","body","awrap","connectToDatabase","setCorsHeaders","Post","findById","sent","json","includes","push","trim","save","t0","console","error","stop"],"mappings":"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","file":"editPost.min.js","sourcesContent":["import mongoose from 'mongoose';\r\nimport { connectToDatabase } from '../utils/db'; // Your connection utility\r\n\r\n// Define the schema for the post\r\nconst postSchema = new mongoose.Schema({\r\n    message: String,\r\n    timestamp: Date,\r\n    username: String,\r\n    sessionId: String,\r\n    likes: { type: Number, default: 0 },\r\n    dislikes: { type: Number, default: 0 },\r\n    likedBy: [String],  // Store usernames or user IDs of users who liked the post\r\n    dislikedBy: [String],  // Store usernames or user IDs of users who disliked the post\r\n    comments: [{ username: String, comment: String, timestamp: Date }]\r\n});\r\n\r\n// Create the model for posts\r\nconst Post = mongoose.model('Post', postSchema);\r\n\r\n// Set CORS headers\r\nconst setCorsHeaders = (res) => {\r\n    res.setHeader('Access-Control-Allow-Origin', '*');  // Allow all origins or specify your domain\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, OPTIONS');  // Allowed methods\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');  // Allowed headers\r\n};\r\n\r\n// Serverless API handler for liking, disliking, or commenting on a post\r\nexport default async function handler(req, res) {\r\n    // Handle pre-flight OPTIONS request\r\n    if (req.method === 'OPTIONS') {\r\n        setCorsHeaders(res);\r\n        return res.status(200).end(); // Respond with 200 OK for OPTIONS pre-flight\r\n    }\r\n\r\n    // Set CORS headers for all other requests\r\n    setCorsHeaders(res);\r\n\r\n    const { postId, username, action, comment } = req.body;\r\n\r\n    try {\r\n        await connectToDatabase(); // Ensure you're connected to the DB\r\n\r\n        if (req.method === 'POST') {\r\n            // Find the post by postId\r\n            const post = await Post.findById(postId);\r\n\r\n            if (!post) {\r\n                return res.status(404).json({ message: 'Post not found' });\r\n            }\r\n\r\n            // Handle the \"like\" action\r\n            if (action === 'like') {\r\n                // Check if the user has already disliked this post\r\n                if (post.dislikedBy.includes(username)) {\r\n                    return res.status(400).json({ message: 'You cannot like a post you have disliked' });\r\n                }\r\n\r\n                // Check if the user has already liked this post\r\n                if (post.likedBy.includes(username)) {\r\n                    return res.status(400).json({ message: 'You have already liked this post' });\r\n                }\r\n\r\n                post.likes += 1;\r\n                post.likedBy.push(username); // Add the user to the likedBy array\r\n\r\n            // Handle the \"dislike\" action\r\n            } else if (action === 'dislike') {\r\n                // Check if the user has already liked this post\r\n                if (post.likedBy.includes(username)) {\r\n                    return res.status(400).json({ message: 'You cannot dislike a post you have liked' });\r\n                }\r\n\r\n                // Check if the user has already disliked this post\r\n                if (post.dislikedBy.includes(username)) {\r\n                    return res.status(400).json({ message: 'You have already disliked this post' });\r\n                }\r\n\r\n                post.dislikes += 1;\r\n                post.dislikedBy.push(username); // Add the user to the dislikedBy array\r\n\r\n            // Handle the \"comment\" action\r\n            } else if (action === 'comment') {\r\n                if (!comment || !comment.trim()) {\r\n                    return res.status(400).json({ message: 'Comment cannot be empty' });\r\n                }\r\n\r\n                post.comments.push({ username, comment, timestamp: new Date() });\r\n\r\n            } else {\r\n                return res.status(400).json({ message: 'Invalid action type' });\r\n            }\r\n\r\n            // Save the updated post\r\n            await post.save();\r\n            return res.json(post);\r\n        } else {\r\n            res.status(405).json({ message: 'Method Not Allowed' });\r\n        }\r\n    } catch (error) {\r\n        console.error(error);\r\n        res.status(500).json({ message: 'Error updating post', error });\r\n    }\r\n}"]}